import os.path
import writer

class PythonWriter(writer.Writer):
    def __init__(self, *args):
        writer.Writer.__init__(self, *args)
        
        if self.parser.enable_strings and self.parser.has_strings:
            #http://bugs.python.org/issue2981
            raise Exception("Python struct doesnt support support strings")

    def _get_exception_name(self, errorid):
        #convert ERROR_NAME --> ErrorName
        bits = [i.title() for i in self.parser.get_error_name(errorid).split("_")]
        return "%sError" % "".join(bits)

    def write_header(self, filename):
        self.f.write("#Autogenerated file, do no edit\n\n")
        self.f.write("import struct\n")

        #write exceptions for all defined parse errors
        for err in self.parser.get_errors():
            self.f.write("\nclass %s(Exception): pass\n" % self._get_exception_name(err))

        self.f.write("\nclass UnpackException(Exception): pass\n")

    def write_struct(self):
        if self.endian == "little":
            fmt_str = "<"
        elif self.endian == "network":
            fmt_str = ">"
        else:
            raise Exception("Endian not supported")

        if self.parser.binary_header:
            fmt_str += 'i'
        
        for chunk in self.parser.parse_tree:
            #Get chunks type and name
            type, name = self.parser.get_chunk_info(chunk)
            #Write each unpack function
            if type == "float":
                fmt_str += 'f'
            elif type == "double":
                fmt_str += 'd'
            elif type == "int":
                fmt_str += 'i'
            elif type == "bool":
                fmt_str += 'B'
            elif type == "string":
                fmt_str += 'p'
                
        if self.parser.binary_footer:
            fmt_str += 'i'

        self.f.write("\nclass %s(struct.Struct):\n" % self.name)
        self.f.write("\tFMT_STRING = \"%s\"\n" % fmt_str)
        self.f.write("\tMAX_SIZE = struct.calcsize(\"%s\")\n" % fmt_str)

        if self.parser.binary_header:
            if self.parser.binary_header[0] == "magic":
                self.f.write("\tBINARY_HEADER = int(\"%s\",16)\n" %  self.parser.binary_header[1])
        
        if self.parser.binary_footer:
            if self.parser.binary_footer[0] == "magic":
                self.f.write("\tBINARY_FOOTER = int(\"%s\",16)\n" %  self.parser.binary_footer[1])
                
        #can we pack/unpack strings
        self.f.write("\tCAN_HANDLE_STRINGS = %s\n" % self.parser.has_strings)

        self.f.write("\tdef __init__(self):\n")
        self.f.write("\t\tstruct.Struct.__init__(self, self.FMT_STRING)\n")

    def write_print_function(self):
        self.f.write("\n\tdef print_plain(self):\n")
        self.f.write("\t\tpass\n")

    def write_csv_functions(self):
        self.f.write("\n\tdef print_csv(self):\n")
        self.f.write("\t\tpass\n")

    def write_pack_functions(self):
        args = []
        #get the function parameters
        for chunk in self.parser.parse_tree:
            type, name = self.parser.get_chunk_info(chunk)
            args.append(name)
        self.f.write("\n\tdef pack_into_buffer(self, %s):\n" % ', '.join(args))
        
        self.f.write("\t\treturn self.pack(")
        if self.parser.binary_header:
            if self.parser.binary_header[0] == "magic":
                self.f.write("self.BINARY_HEADER, ")
        
        self.f.write(', '.join(args))
        
        if self.parser.binary_footer:
            if self.parser.binary_footer[0] == "magic":
                self.f.write(", self.BINARY_FOOTER")
                
        self.f.write(")\n")

    def write_unpack_function(self):
        args = []
        #get the function parameters
        for chunk in self.parser.parse_tree:
            type, name = self.parser.get_chunk_info(chunk)
            args.append(name)
        if self.parser.binary_header:
            args.insert(0, "binary_header")
        if self.parser.binary_footer:
            args.append("binary_footer")

        self.f.write("\n\tdef unpack_from_buffer(self, buf):\n")
        self.f.write("\t\ttry:\n")
        self.f.write("\t\t\t%s = self.unpack(buf)\n" % ", ".join(args))
        self.f.write("\t\texcept struct.error,e:\n")        
        self.f.write("\t\t\traise UnpackException(\"Error parsing buffer\")\n")
        
        if self.parser.binary_header:
            if self.parser.binary_header[0] == "magic":
                self.f.write("\n\t\tif binary_header != self.BINARY_HEADER:\n")
                self.f.write("\t\t\traise %s(\"%%x != %%x\" %% (binary_header,self.BINARY_HEADER))\n" % 
                                    self._get_exception_name(self.parser.ERROR_HEADER_MAGIC))
            #dont return the header
            args.remove("binary_header")

        if self.parser.binary_footer:
            if self.parser.binary_footer[0] == "magic":
                self.f.write("\n\t\tif binary_footer != self.BINARY_FOOTER:\n")
                self.f.write("\t\t\traise %s(\"%%x != %%x\" %% (binary_footer,self.BINARY_FOOTER))\n" %
                                    self._get_exception_name(self.parser.ERROR_FOOTER_MAGIC))

            #dont return the footer
            args.remove("binary_footer")
                
        self.f.write("\n\t\treturn %s\n" % ", ".join(args))

    def write_footer(self):
        pass


